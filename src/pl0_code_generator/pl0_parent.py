
from copy import copy

from ete3 import Tree

from src.pl0_code_generator.instructions import Inst, Op
from src.pl0_code_generator.pl0_const import Pl0Const
from src.syntax_analyzer.symbol_record import SymbolRecord
from src.syntax_analyzer.symbol_table import find_entry_in_symbol_table


class Pl0Parent(Pl0Const):

    def __init__(self, abstract_syntax_tree: Tree, symbol_table) -> None:
        """
        The function takes in an abstract syntax tree and initializes the code, ast, and stck attributes.

        :param abstract_syntax_tree: This is the abstract syntax tree that was generated by the parser
        :type abstract_syntax_tree: Tree
        """
        super().__init__()
        self.code = []
        self.ast = abstract_syntax_tree
        self.symbol_table = symbol_table
        self.curr_func_name = None
        # [JT] current scope in the tree, ie if we are in global scope (0) or in function scope (<id>)
        # used for symbol table navigation
        self.current_scope = 0

    def generate_instruction(self, inst_name, param1, param2):
        """
        It appends a list of three elements to the list called code

        :param inst_name: The name of the instruction
        :param param1: the first parameter of the instruction
        :param param2: the value of the second parameter
        """
        self.code.append([inst_name, param1, param2])

    def print_code(self, out_method):
        """
        It prints the code of the program
        """
        for index, c in enumerate(self.code):
            out_method(str(index) + " " + "" + str(c[0]) + " " + str(c[1]) + " " + str(c[2]))

    def print_symbol_table(self, out_method):
        """
        It prints the symbol table
        """
        symbol_table_to_print = copy(self.symbol_table)
        scopes = symbol_table_to_print["_scopes"]
        del symbol_table_to_print["_scopes"]
        [symbol_table_to_print.update(i) for i in scopes]
        for i in symbol_table_to_print.values():
            if i.type == "func":
                out_method(i.__str__())

                if i.params is not None:
                    out_method("--------params--------\n")
                    for j in i.params.values():
                        out_method(j.__str__())

                if i.locals is not None:
                    out_method("--------locals--------\n")
                    for k in i.locals:
                        for m in k.values():
                            out_method(m.__str__())
            else:
                out_method(i.__str__())

    def return_code(self) -> str:
        """
        This function returns a string of the code in the format of "index opcode operand1 operand2"
        :return: The return_code method returns a string of the code.
        """
        code_string = ""
        for index, c in enumerate(self.code):
            code_string += (str(index) + " " + str(c[0]) + " " + str(c[1]) + " " + str(c[2]) + "\n")
        return code_string

    def gen_const(self, const, symbol_table=None, real_level=0):
        """
        It generates a constant
        :param const: The constant to be generated
        """
        if type(const) == int:
            self.generate_instruction(self.inst(Inst.lit), 0, const)
            return
        symbol = find_entry_in_symbol_table(symbol_table, self.current_scope, real_level, const)
        if symbol is not None:
            self.gen_load_symbol(symbol)

    def store_var(self, var: SymbolRecord):
        """
        Store a variable in the current scope.

        :param var: The variable to store
        :type var: SymbolRecord
        """
        self.generate_instruction(self.inst(Inst.sto), var.level, var.address)

    def gen_load_symbol(self, symbol: SymbolRecord):
        """
        It generates the code to load a symbol from the symbol table

        :param symbol: The symbol record for the symbol to be loaded
        :type symbol: SymbolRecord
        """
        self.generate_instruction(self.inst(Inst.lod), symbol.level, symbol.address)

    def correct_jmc_for_logical_condition(self, x):
        for i in self.code:
            if i[2] == "or_mark":
                i[2] = len(self.code) + 1
            if i[2] == "and_mark":
                i[2] = x

    def gen_opr(self, const1, operator: Op, const2, symbol_table=None, real_level=0):
        """
        It generates instructions for the operation of two constants
        :param const1: The first constant to be used in the operation
        :param operator: o = enum('+', '-', '*', '/', '<', '>', '=', '<=', '>=', '<>', 'and', 'or', 'not', 'neg')
        :type operator: o
        :param const2: The second constant to be used in the operation
        """
        if const1:
            self.gen_const(const1, symbol_table, real_level=real_level)
        if const2:
            self.gen_const(const2, symbol_table, real_level=real_level)
        self.generate_instruction(self.inst(Inst.opr), 0, str(operator))

    def gen_opr_add(self, const1=None, const2=None, symbol_table=None, real_level=0):
        self.gen_opr(const1, self.op(Op.add), const2, symbol_table=symbol_table, real_level=real_level)

    def gen_opr_sub(self, const1=None, const2=None, symbol_table=None, real_level=0):
        self.gen_opr(const1, self.op(Op.sub), const2, symbol_table=symbol_table, real_level=real_level)

    def gen_opr_mul(self, const1=None, const2=None, symbol_table=None, real_level=0):
        self.gen_opr(const1, self.op(Op.mul), const2, symbol_table=symbol_table, real_level=real_level)

    def gen_opr_div(self, const1=None, const2=None, symbol_table=None, real_level=0):
        self.gen_opr(const1, self.op(Op.div), const2, symbol_table=symbol_table, real_level=real_level)

    def gen_term(self, const1=None, const2=None, symbol_table=None, real_level=0):
        self.gen_const(const1, symbol_table=symbol_table, real_level=real_level)

    def gen_sub(self, operator):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.sub))

    def gen_add(self, operator):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.add))

    def gen_mulby(self, operator):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.mul))

    def gen_divby(self, operator):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.div))

    def gen_lesser(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.lt))

    def gen_not_equal(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.ne))

    def gen_lesser_equals(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.le))

    def gen_greater(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.gt))

    def gen_greater_equals(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.ge))

    def gen_dos_equals(self):
        self.generate_instruction(self.inst(Inst.opr), 0, self.op(Op.eq))

    @staticmethod
    def inst(instruction: Inst):
        """
        It takes an instruction and returns its value

        :param instruction: The instruction to be executed
        :type instruction: t
        :return: The value of the instruction.
        """
        return instruction.value

    @staticmethod
    def op(operation: Op):
        """
        Return the value of the operation.

        :param operation: The operation to perform
        :type operation: o
        :return: The value of the operation.
        """
        return operation.value

    @staticmethod
    def clear_tree(tree_iter_generator):
        """
        It takes a generator that yields tree iterators, and clears the tree of all rows
        :param tree_iter_generator: A generator that returns a Gtk.TreeIter for each row in the tree
        """
        sub_tree = []
        for i in tree_iter_generator:
            if not i[0]:
                sub_tree.append(i[1])
        return sub_tree
